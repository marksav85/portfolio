{
  "headerSection": {
    "buttonText": "DE",
    "line1": "Mein Name ist ",
    "line2": ", und diese Seite ",
    "line3": "ist mein personalisiertes Portfolio",
    "line4": "entwickelt mit ",
    "name": "Mark",
    "codeLang": "React"
  },
  "profileSection": {
    "line1": "Ich bin ein Full Stack Web Developer, der in Großbritannien geboren wurde, aber in Deutschland wohnt.",
    "line2": "Full-Stack-Webentwickler mit einem Hintergrund in Bildung und Technologie. Fähigkeiten in der Erstellung von Front-End- und Back-End-Anwendungen, einschließlich Webseiten und sowohl progressive web-apps (PWA) als auch nativen Anwendungen. Ich spezialisiere mich hauptsächlich auf Single Page Applications (SPAs) mit React, mit reaktionsschnellen, zugänglichen und benutzerfreundlichen Designs, einschließlich kundenorientierter Funktionen, Entwicklung, Tests, Fehlersuche und Launch. React ist ein schnelles, flexibles und modernes Framework für die Entwicklung von Websites und Web-Apps, das leichtgewichtige und reaktionsfähige Designs mit modernen Funktionen kombiniert und so das Benutzererlebnis verbessert."
  },
  "aboutSection": {
    "skillsHeader": "Entwicklerkompetenzen",
    "techTableHeader": "Technologien",
    "expertiseTableHeader": "Kompetenz"
  },
  "toggleSkills": {
    "hide": "Verbergen",
    "show": "Anzeigen"
  },
  "workTitle": {
    "title": "Meine Arbeit",
    "addTitle": "Zusätzliche Arbeit"
  },
  "projectLabels": {
    "introTitle": "Was ist das?",
    "processTitle": "der Entwicklungsprozess",
    "descTitle": "Projektbeschreibung",
    "technologies": "Entwickelt mit: ",
    "visitSite": "Besuche die Seite: ",
    "visitRepo": "Besuche das Repository: "
  },
  "project1": {
    "introText": "Eine App, die die Seite dynamisch mit Pokemon-Daten aus einer API auffüllt. Die App ermöglicht es dir, die Liste nach einem Pokemon anhand seines Namens zu durchsuchen. Wenn du darauf klickst, erscheint ein modales Fenster mit dem Namen, dem Typ und einem Bild des Pokemons. Sie wurde mit JavaScript, HTML und CSS mit Bootstrap-Styling erstellt.",
    "para1": "Das Ziel dieses Projekts war die Beherrschung von JavaScript, um eine App zu erstellen, die effizient Daten von einer API abrufen und sie mit Hilfe von Bootstrap-Karten und Modals auf der Seite anzeigen kann. Die API-Daten waren im Json-Format gespeichert. Sie mussten also mit JavaScript-API-Aufrufen abgerufen und dann dem DOM hinzugefügt werden, indem die erforderlichen HTML-Elemente erstellt und angehängt wurden, um die Daten korrekt anzuzeigen.",
    "para2": "Ich startete diese Aufgabe, indem ich ein grundlegendes HTML-Layout anlegte, das ich später zum Einfügen der relevanten Elemente und API-Daten aus JavaScript verwenden konnte. Als nächstes begann ich mit der Arbeit an JavaScript-Versprechen, führte gründliche Tests durch und nutzte die Konsolenprotokollierung, um Probleme in den API-Aufrufen zu identifizieren. Durch diesen iterativen Ansatz konnte ich die Probleme effektiv beheben und die Daten erfolgreich aus der API abrufen. Sobald ich die benötigten Daten erfolgreich abrufen konnte, begann ich damit, die API-Daten in die Seite zu integrieren, indem ich die erforderlichen Bootstrap-Elemente und -Klassen anlegte und sie zusammen mit den Daten an die Seite anfügte. Nach einigen Tests und Änderungen am Code und Styling reichte dies aus, um die zu Beginn des Projekts aufgestellten Kriterien erfolgreich zu erfüllen. Ein Problem, das ich nur schwer lösen konnte, betraf die Leistung - es gab eine kleine, aber spürbare Verzögerung bei der Anzeige der Daten auf der Seite, die zum ersten Mal geladen wurde. Nachdem ich verschiedene Lösungen ausprobiert hatte, einschließlich der Anpassung von asynchronen Anfragen, stellte sich heraus, dass diese Verzögerung größtenteils unvermeidlich war (die Zeit, die benötigt wurde, um die Daten von der API abzurufen und sie auf die Seite zu laden). Um dieses Problem zu umgehen, fügte ich einen Ladebildschirm mit einem animierten Fortschrittsbalken hinzu, der beim Laden der Seite erschien und dann verschwand, nachdem die Pokémon-Daten erfolgreich geladen worden waren.",
    "para3": "Nachdem ich die Ziele des Projekts erreicht und seine Funktionalität überprüft hatte, machte ich mich daran, zusätzliche Features hinzuzufügen, die das Projekt meiner Meinung nach verbessern würden. Zunächst fügte ich mit Hilfe von Bootstrap-Formularklassen eine Suchleiste in den HTML-Code ein, mit der der Benutzer nach seinem Lieblings-Pokémon suchen kann. Damit dies funktioniert, habe ich eine Filtermethode im JavaScript verwendet, die nur die Pokémon anzeigt, die dem vom Benutzer eingegebenen Text entsprechen, und den Rest ausblendet. Außerdem fügte ich für jedes Pokémon eine Kartenfarbe auf der Grundlage seines Pokémon-Typs hinzu. Dazu musste ich zunächst auf die entsprechenden Json-Daten aus der API zugreifen und sie überprüfen und dann die passende Klassenfarbe zu dieser Karte hinzufügen, um jedem Typ eine eigene Farbe zu geben.",
    "para4": "Das Endergebnis dieser Bemühungen war die erfolgreiche Erstellung einer Pokémon-Datenbankanwendung, die fast vollständig in JavaScript geschrieben wurde. Das erfolgreiche Abrufen der Daten und die dynamische Anzeige auf der Seite reichten aus, um ein erfolgreiches Projekt anzulegen. Ich denke jedoch, dass die zusätzlichen Features der Suchnavigation und des Ladebildschirms die App zu einem viel benutzerfreundlicheren Produkt gemacht haben.",
    "technologies": "HTML, CSS, Bootstrap, JavaScript"
  },
  "project2": {
    "introText": "Die serverseitige Komponente einer Filmanwendung im IMDB-Stil. Sie enthält eine Datenbank mit Daten zu verschiedenen Filmen, wie z.B. das Genre, die Beschreibung, das Titelbild usw., Informationen über registrierte Benutzer (einschließlich Datensicherheitsmethoden) und Endpunkte, die eingerichtet wurden, um clientseitigen Anwendungen die Interaktion mit der Datenbank zu ermöglichen.",
    "para1": "Die Hauptanforderung bei diesem Projekt war der Aufbau einer Datenbank mit Filmen und den dazugehörigen Daten. Die Datenbank musste von clientseitigen Anwendungen aus zugänglich sein und CRUD-Operationen ermöglichen. Außerdem sollte die Datenbank clientseitigen Anwendungen ermöglichen, Daten über registrierte Benutzer zu speichern und abzurufen, damit diese sich registrieren und anmelden können.",
    "para2": "Ich startete, indem ich Node.js und Express verwendete, um die wesentlichen Anfragen und Endpunkte anzulegen, die die relevanten CRUD-Anfragen für die clientseitige Anwendung ermöglichen würden. Der nächste Schritt war die Erstellung der Datenbank. Hierfür wurde MongoDB aufgrund seiner Zuverlässigkeit und Leistung, aber auch wegen seiner Flexibilität als relationale Datenbank gewählt. Dies ermöglichte die Erstellung eines eigenen Schemas für das Projekt, das mit Mongoose angelegt wurde. Nachdem das Schema, die Endpunkte und Sammlungen in MongoDB eingerichtet waren, habe ich postman verwendet, um CRUD-Operationen der Datenbank über die angegebenen Endpunkte zu testen. Bei der Durchführung von CRUD-Operationen mit dem Benutzer fehlte jedoch noch eine Schlüsselkomponente - die Benutzerauthentifizierung und -validierung. Dies wurde durch JSON-Web-Token erledigt, die für jeden Benutzer ein Token generierten. Dies wiederum erforderte das Middleware-Paket Passport, das mit Express arbeitet, um Token zu validieren und Benutzer zu authentifizieren. Um die Funktionalität sicherzustellen, habe ich erneut postman verwendet, um die Endpunkte zu testen.",
    "para3": "Eine der wichtigsten Verbesserungen, die ich vornehmen wollte, stellte jedoch auch die größte Challenge dar - eine Verschlüsselungsmethode zur Verbesserung der Sicherheit bei der Authentifizierung und Autorisierung. Um dieses Problem zu lösen, wandte ich mich an bcrypt, das das Hashing von Passwörtern ermöglichte und die Sicherheit der registrierten Benutzer erheblich verbesserte. Die Einrichtung von bycrypt zum korrekten Hashing von Passwörtern erwies sich als schwierig. Glücklicherweise verfügt es jedoch über eine umfangreiche Dokumentation, auf die ich mich immer wieder beziehen konnte.",
    "para4": "Das Ergebnis war ein voll funktionsfähiges und sicheres Datenbanksystem. Die Backend-Infrastruktur ermöglichte die Speicherung und den Abruf von Film- und Benutzerdaten. Token-basierte Autorisierungs- und Authentifizierungsmechanismen sorgten für ein hohes Maß an Datensicherheit und gewährleisteten die Privatsphäre der Benutzer. Aufgrund der Komplexität der bei der Implementierung erforderlichen Schritte und um die Lesbarkeit und Wartbarkeit des Codes zu verbessern, fügte ich außerdem JSDoc-Kommentare hinzu, um eine umfassende Dokumentation der Codebasis zu erhalten.",
    "technologies": "JavaScript, Node.js, Express, MongoDB, Mongoose, Postman"
  },
  "project3": {
    "introText": "Die clientseitige Komponente einer Filmanwendung. Die Single-Page-Anwendung (SPA), mit der sich Benutzer anmelden, Filmdaten anzeigen und ihre Daten aktualisieren, suchen und Lieblingsfilme hinzufügen oder entfernen können.",
    "para1": "Das Ziel war die Entwicklung einer benutzerfreundlichen und mit vielen Features ausgestatteten SPA zum Durchsuchen von Filmen mit React und React Bootstrap. Die App sollte es Benutzern ermöglichen, sich zu registrieren und registrierte Benutzer sollten sich bei der App anmelden können. Nach der Anmeldung können die Benutzer eine Liste mit Informationen durchsuchen, auf einen Film klicken, um detailliertere Informationen zu erhalten, und zu einer Profilseite navigieren, auf der sie ihre Daten einsehen und aktualisieren sowie ihr Konto löschen können.",
    "para2": "React wurde für dieses Projekt ausgewählt, weil es den Ruf hat, eine reibungslose und reaktionsschnelle Leistung zu bieten, ein gut dokumentiertes und unterstütztes Framework/eine gut dokumentierte Bibliothek zu sein und über clientseitige Rendering-Fähigkeiten zu verfügen. Ich habe das Projekt mit Parcel als Build-Tool eingerichtet, da es einfach ist und viele Minifier und Optimierungen enthält, die es für kleine Projekte geeignet machen. Sobald das Projekt eingerichtet war, startete ich mit dem Anlegen der Hauptseitenkomponente, gefolgt von der Hauptkomponente für die Filmliste. Ich richtete die erforderliche Logik ein, um die Filme aus der Datenbank zu holen und sie in die Komponente und dann in die detaillierte Filmkomponente einzuspeisen. React Bootstrap-Kartenklassen wurden verwendet, um die Daten anzuzeigen und ihnen ein grundlegendes Styling zu geben. Sobald dies abgeschlossen war, habe ich die Komponenten für die Anmeldung und die Benutzerregistrierung angelegt. React Router wurde verwendet, um sicherzustellen, dass Besucher ohne gültiges Token auf diese Willkommensseite umgeleitet werden. React Bootstrap-Formulare wurden verwendet, um Benutzereingaben zu ermöglichen, und dann wurde die Logik zum Senden und Abrufen der entsprechenden CRUD-Operation an die Movie API-Datenbank angelegt. Das abgerufene Token wird im Browser gespeichert, so dass sich der Benutzer anmelden kann. Die letzte wichtige Komponente war die Profilseite. Sie enthielt eine Anzeige für die Benutzerdaten, ein Formular zur Aktualisierung der Benutzerdaten und eine Schaltfläche zum Löschen des Kontos. Die Implementierung dieses Formulars zur Aktualisierung der Benutzerdaten war vielleicht die größte Herausforderung bei diesem Projekt. Die Aktualisierung und Verschlüsselung der an den Server gesendeten Daten und die Rückgabe und Aktualisierung der Benutzerdaten auf derselben Seite erwiesen sich als schwierig. Ich fand es jedoch einfacher, dieses Problem zu lösen, indem ich die Seite in mehrere Unterkomponenten aufteilte, um die Daten des Benutzers und das Formular zur Aktualisierung des Benutzers anzuzeigen. Auf diese Weise konnte ich die neuen Daten über Props übergeben, was die Probleme mit der Aktualisierung der Benutzerinformationen fast nahtlos löste.",
    "para3": "Nachdem ich die wesentlichen Komponenten fertiggestellt und die Funktionalität getestet hatte, beschloss ich, einige zusätzliche Verbesserungen vorzunehmen, um das Projekt zu erweitern. Die erste bestand darin, die Benutzerfreundlichkeit und die Sicherheit zu verbessern, indem ich die Formulare mit einer Validierungslogik versah, um Skripting-Angriffe zu verhindern und dem Benutzer bei ungültigen Eingaben eine Rückmeldung zu geben. Weitere Verbesserungen der Benutzerfreundlichkeit wurden durch die Verwendung von React Bootstrap-Warnungen erzielt, die mit entsprechenden Fehlermeldungen aktualisiert werden. Außerdem fügte ich der Profilseite eine Favoritenliste hinzu, indem ich der Liste der Filme eine Favoriten-Schaltfläche hinzufügte. Sobald ein Benutzer auf die Schaltfläche Favorit klickt, wird der Film zu einer neuen Liste hinzugefügt, die im Profilbereich in einer neuen Unterkomponente angezeigt wird. Sie können den Film auch wieder aus der Liste entfernen, indem Sie auf dieselbe Schaltfläche klicken. Und schließlich habe ich, obwohl React Bootstrap ohne eigenes Styling geliefert wurde, angepasste CSS-Stylings hinzugefügt, um der App ein modernes und einzigartiges Aussehen zu verleihen.",
    "para4": "Das Endprodukt war eine zufriedenstellende Integration von React und React Bootstrap, die nicht nur die Projekterwartungen erfüllte, sondern auch wertvolle Erfahrungen bei der erfolgreichen Erstellung einer interaktiven, reaktionsfähigen und visuell ansprechenden Webplattform in Kombination mit aktuellen Verschlüsselungs- und Sicherheitsstandards lieferte.",
    "technologies": "React, React Bootstrap, JavaScript, Parcel, JSDoc"
  },
  "project4": {
    "introText": "Eine progressive Web-App (PWA), mit der Sie nach Orten suchen können, um zu sehen, welche Veranstaltungen in der jeweiligen Stadt stattfinden. Die Authentifizierung erfolgt über Google und erfordert daher ein Google-Konto. Die App kann auf dem Desktop oder dem Homescreen gespeichert werden, um den Zugriff zu erleichtern, und ermöglicht Offline-Funktionalität.",
    "para1": "Ziel dieses Projekts war es, eine progressive Web-App (PWA) anzulegen, auf die sowohl online über das Internet zugegriffen werden kann als auch als Web-App auf dem Desktop oder dem Smartphone-Homescreen gespeichert werden kann. Als PWA würde die App schnelles Laden, Offline-Funktionalität und plattformübergreifende Funktionalität bieten. Der Zugriff auf die App würde über Google OAuth2.0 erfolgen. Auf der App-Hauptseite können Benutzer nach einer Liste von Städten suchen. Eine API-Anfrage ruft eine Liste von Veranstaltungen an diesem Ort ab und zeigt sie auf der Seite an. Die Anzeige würde die Daten in Listenform anzeigen und weitere Details aus einem Dropdown-Menü anzeigen, wenn Sie darauf klicken. Außerdem würden bei diesem Projekt kontinuierliche Tests durchgeführt, um einen automatisierten und konsistenten Code zu gewährleisten.",
    "para2": "Ich begann mit dem Frontend der App und verwendete erneut React und React Bootstrap aufgrund seiner Einfachheit und seiner Fähigkeit, responsive SPAs zu erstellen. Die ersten Komponenten wurden so eingerichtet, dass sie mit Hilfe eines Eingabeformulars nach Städten suchen und Veranstaltungsdetails wie Startzeiten, Orte und Beschreibungen anzeigen. Ein benutzerfreundliches Feature ermöglicht es, weitere Daten zur Veranstaltung anzuzeigen. Mit Hilfe von Dummy-Daten, die zu Testzwecken erstellt wurden, konnte ich dann Daten in die App einspeisen, um sicherzustellen, dass sie korrekt angezeigt wurden. Nachdem ich die Grundstruktur der App eingerichtet hatte, begann ich nach der Technik der testgetriebenen Entwicklung (TDD) mit dem Schreiben von Unit-Tests, gefolgt von Integrationstests, um sicherzustellen, dass die Teile einzeln und zusammen funktionieren. Als Testsuite wurde JEST gewählt, da sie gut dokumentiert ist und für beide Testansätze verwendet werden kann. Dann begann ich mit dem Schreiben von Akzeptanztests mit Cucumber und der Implementierung der entsprechenden Features und anschließend mit End-to-End-Tests mit Puppeteer. Ich fand es eine ziemliche Herausforderung, sicherzustellen, dass alle Tests korrekt bestanden, da das Schreiben des Tests und die anschließende Implementierung des korrekten Codes, damit der Test erfolgreich war, ziemlich zeitaufwändig war. Die Verwendung von Online-Ressourcen wie Spickzetteln half mir jedoch enorm, diesen Prozess zu beschleunigen und sicherzustellen, dass meine Tests korrekt geschrieben waren. Nachdem ich sichergestellt hatte, dass alle Tests mit den Dummy-Daten erfolgreich waren, begann ich mit der Arbeit an den Backend-Anfragen, um die API-Daten von der Google Calendar API zu erhalten. Anstatt eine traditionelle Serverarchitektur zu verwenden, wurden Serverless Lambda-Funktionen, die von AWS gehostet werden, aufgrund ihrer Verfügbarkeit und geringen/keinen Wartungsaufwand verwendet. Diese wurde mit Google Services verbunden, um die Authentifizierung über Google OAuth2.0 zu ermöglichen. Auf diese Weise konnte sich ein Benutzer über Google anmelden und die relevanten Ereignisse aus der Google Calendar API abrufen. Nachdem ich sichergestellt hatte, dass alle Tests erfolgreich verliefen, konnte ich mit der Implementierung der Offline-Funktionalität und dem Speichern auf dem Desktop/Home-Screen mithilfe von Service Workern beginnen.",
    "para3": "Obwohl die App alle Tests bestand und alle angestrebten Funktionen erfüllte, hatte ich immer noch das Gefühl, dass sie nicht so optisch attraktiv war, wie sie sein könnte. Um dieses Problem zu lösen, wurde ein grafisches Overlay mit einer Visualisierungsbibliothek implementiert, um die API-Daten in eine visuelle Aufschlüsselung der Ereignistypen und -mengen an jedem Ort umzuwandeln, zusätzlich zur bereits implementierten Listenansicht. Dadurch wurde die App bunter und visuell interessanter. Zusammen mit einem angepassten Styling sah die App viel ansprechender aus. Das zusätzliche grafische Overlay musste dann in die Tests integriert werden, um sicherzustellen, dass es auch wirklich wie vorgesehen funktionierte. Der letzte Schritt war die Verwendung der Google Lighthouse PWA-Checkliste und eines Online-Performance-Tools, um sicherzustellen, dass die App wie erwartet funktionierte.",
    "para4": "Das Endprodukt war eine optisch ansprechende und reaktionsschnelle PWA mit sofortigem Laden, Offline-Unterstützung, Push-Benachrichtigungen, der Aufforderung 'zum Homescreen hinzufügen' und plattformübergreifender Kompatibilität. Die serverlose Funktion ermöglichte eine einfache, wartungsarme Backend-Option und der TDD-Ansatz führte dazu, dass alle Fehler während des Build-Prozesses erkannt und beseitigt wurden.",
    "technologies": "React, Bootstrap, JavaScript, AWS Lambda, Google API Services, Jest"
  },
  "project5": {
    "introText": "Eine Chat-App im Stil von WhatsApp für mobile Geräte. Benutzer können ihren Namen und ihre Hintergrundfarbe auswählen und dann den Chat-Raum betreten, in dem sie Nachrichten senden, Fotos senden und aufnehmen, ihren Standort übermitteln und Sprachnachrichten aufnehmen und versenden können. Da es sich um eine native mobile App handelt, muss sie auf einem mobilen Gerät installiert und betrieben werden.",
    "para1": "Das Ziel war die Entwicklung einer plattformübergreifenden Chat-Anwendung mit React Native, die sowohl mit Apple- als auch mit Android-Betriebssystemen kompatibel ist. Die App sollte ein nahtloses mobiles Erlebnis bieten und es den Benutzern ermöglichen, in Echtzeit zu chatten, Bilder auszutauschen, Standortdaten zu teilen und Sprachnachrichten aufzunehmen. Die Implementierung von Features wie Echtzeitkommunikation, Medienfreigabe und Authentifizierung bei gleichzeitiger Gewährleistung einer reibungslosen Funktionalität auf verschiedenen Geräten waren die Anforderungen dieses Projekts.",
    "para2": "Zunächst habe ich die Chat-App mit React Native entwickelt, um die Kompatibilität sowohl mit Apple- als auch mit Android-Plattformen sicherzustellen. Da ich mit React Native vertraut bin, konnte ich die grundlegende Struktur und Funktionalität der App schnell erstellen. Die App wurde kontinuierlich mit Expo als Simulator für das iPhone und Android Studio als Emulator getestet. Während sich Expo problemlos einrichten ließ, hatte ich mit Android Studio einige anfängliche Probleme. Um diese zu beheben, musste ich Anleitungen und Dokumentationen durchlesen, um die Einstellungen auf meinem Gerät zu wechseln. Nach einiger Geduld funktionierte es schließlich erfolgreich, so dass ich eine Verbindung herstellen und meine App testen konnte. Die Chat-Oberfläche und -Funktionalität wurde mit der Gifted Chat-Bibliothek angelegt, da sie sich gut in React Native integrieren ließ und den Benutzern die Möglichkeit bot, ihr Erlebnis durch die Eingabe ihres Namens und die Auswahl eines Hintergrunds individuell zu gestalten. Die Kommunikation in Echtzeit wurde über Socket.IO ermöglicht, so dass die Benutzer sofort chatten können. Dann richtete ich die Funktionalität ein, um Bilder aus der Bildbibliothek des Geräts zu versenden, Bilder mit der Kamera des Geräts aufzunehmen und Standortdaten über eine Kartenansicht zu teilen. Als dies abgeschlossen war, entschied ich mich für Google Firebase als NoSQL-Dokumentendatenbank, um den Cloud-Speicher zu verwalten, und asyncStorage, um den Zugriff auf die Nachrichten zu ermöglichen, wenn sie offline sind. Damit konnten sich die Benutzer anonym ein- und ausloggen und ihren Chatverlauf anhand ihrer ID einsehen und frühere Nachrichten und Medien sowohl online als auch offline abrufen.",
    "para3": "Ein weiteres Feature, das ich implementiert habe, waren Sprachaufnahmen. Da die meisten Geräte inzwischen über dieses Feature verfügen, war es über die expo-av Bibliothek zugänglich. Sie war gut dokumentiert und ermöglichte eine einfache Integration neben den bereits implementierten Features.",
    "para4": "Das Ergebnis war eine vielseitige und benutzerfreundliche plattformübergreifende Chat-Anwendung. Die Benutzer konnten in Echtzeit interagieren, Bilder austauschen, Standortdaten weitergeben und mühelos Sprachnachrichten aufzeichnen und damit alle Ziele des Projekts erreichen. Die Kompatibilität der App sowohl mit Apple- als auch mit Android-Geräten sorgte für eine breite Benutzerbasis. Die Integration von Socket.IO ermöglichte eine nahtlose Kommunikation in Echtzeit und verbesserte das Benutzererlebnis. Die Verwendung von Google Firestore für die anonyme Benutzerauthentifizierung und Firebase für die Verwaltung der Datenbank und des Cloud-Speichers rationalisierte die Backend-Prozesse der App. Insgesamt erfüllte die Chat App erfolgreich die Projektanforderungen, ermöglichte es mir, React Native und Firebase zu erlernen, und bot den Benutzern eine ansprechende und interaktive Plattform für die Kommunikation und den Austausch von Medien.",
    "technologies": "React Native, Expo, Android Studio, Firebase"
  },
  "project6": {
    "introText": "Die clientseitige Anwendung zum Registrieren und Anzeigen einer Filmdatenbank, die TypeScript und Angular verwendet und Angular Material für das Styling einsetzt. Typedoc wird zum Kommentieren der Codebasis und für die Dokumentation verwendet.",
    "para1": "Das Ziel war die Entwicklung einer alternativen clientseitigen Anwendung für die MyFlix Filmdatenbank. Ziel war es, mit TypeScript und Angular eine robuste und sichere Anwendung mit erweiterter Funktionalität anzulegen. Die Überwindung der Lernkurve, die mit der strukturierten Ordnerorganisation von Angular und der strengen Typisierung von TypeScript verbunden ist, war eine große Herausforderung, aber entscheidend, um die Robustheit und Sicherheit der Anwendung zu gewährleisten. Die App musste auch Features zur Benutzerauthentifizierung integrieren, die es den Benutzern ermöglichen, sich anzumelden, ihre Daten zu aktualisieren, ihre Lieblingsfilme zu verwalten und detaillierte Filmdaten aus der serverseitigen Filmdatenbank abzurufen.",
    "para2": "Nachdem das Projekt eingerichtet war, startete ich mit dem Anlegen der Hauptkomponente für die Filmliste und richtete die erforderliche Logik ein, um die Filme aus der Datenbank zu holen und sie in die Komponente und dann in die detaillierte Filmkomponente einzuspeisen. Die grundlegenden Seitenlayouts wurden mit HTML, aber unter Verwendung von Angular Material-Klassen und -Styles erstellt, wodurch das Layout schnell und einfach angelegt werden konnte und eine optisch ansprechende und reaktionsfähige Benutzeroberfläche bot. Die Einarbeitung in das strukturierte Ordnersystem von Angular und Angular Material war anfangs neu, aber beide sind gut dokumentiert. Bei der Verwendung von TypeScript wurde die Logik zum Abrufen von API-Daten in einer fetch-api-Datei platziert, auf die alle Komponenten über den Import zugreifen können, während die Komponentenfunktionen im jeweiligen Komponentenordner platziert wurden, was ich strukturell logisch und einfach zu befolgen fand. An die strenge Typisierung von TypeScript musste ich mich erst gewöhnen, aber sie ist auch gut dokumentiert und ich fand, dass sie Bugs und Fehler im Code deutlich reduziert, so dass weniger Debugging erforderlich war. Sobald die Filmkomponenten fertig waren, habe ich mich daran gemacht, die Komponenten für die Willkommensseite, die Anmeldung und die Benutzerregistrierung anzulegen. Die Verwendung von Angular Material für die Benutzeroberfläche und der Import eines Großteils der Komponentenlogik aus der bereits angelegten fetch-api machten dies zu einer relativ schmerzlosen Aufgabe. Ähnlich wie beim React-Client wurde eine Web-Token-Authentifizierung verwendet, damit sich der Benutzer anmelden kann. Anschließend wurde eine Navigationsleiste mit routerLink hinzugefügt, um die Navigation zwischen den Seiten zu ermöglichen. Die letzte wesentliche Komponente war die Profilseite, die das Löschen von Konten, die Anzeige von Benutzerdaten und die Aktualisierung von Benutzerdaten umfasst. Wie bei den vorherigen Komponenten wurde Angular Material verwendet und eine CRUD-Operationslogik mit TypeScript angelegt, um die Daten des Benutzers zu aktualisieren und das Konto zu löschen.",
    "para3": "Nachdem alle Komponenten fertiggestellt waren, beschloss ich, einige zusätzliche Features einzubauen, um die Seite attraktiver zu gestalten. Die erste war, neben den Filmdetails für jeden Film eine Favoriten-Schaltfläche hinzuzufügen. Damit können Sie Filme bevorzugen oder nicht bevorzugen. Dann fügte ich einen zusätzlichen Bereich in der Profilkomponente hinzu, in dem die favorisierten Filme angezeigt wurden - im Grunde eine Favoritenliste. Weitere Verbesserungen der Benutzerfreundlichkeit wurden mit angepassten CSS-Stylings zusammen mit dem Angular Material-Layout hinzugefügt, um der App ihren eigenen modernen und einzigartigen Look zu verleihen.",
    "para4": "Die fertige Anwendung war eine benutzerfreundliche und moderne Client-seitige Filmanwendung. Durch die Überwindung der Lernkurve und die Nutzung des strukturierten Ansatzes von Angular und der strengen Typisierung von TypeScript erreichte die Anwendung ein hohes Maß an Robustheit und Sicherheit. Die Dokumentation von Typedoc wurde durchgängig verwendet, um eine umfassende und zugängliche Dokumentation der Codebasis zu gewährleisten, die die Wartung und zukünftige Entwicklung erleichtert. Die mit Angular Material gestaltete Benutzeroberfläche der Anwendung bot ein optisch ansprechendes und reaktionsschnelles Erlebnis für die Benutzer. Insgesamt hat das Projekt erfolgreich eine clientseitige Komponente geliefert, die die Anforderungen erfüllte und den Benutzern ein nahtloses Filmblättererlebnis bot.",
    "technologies": "Angular, Angular Material, TypeScript, TypeDoc"
  },
  "project7": {
    "introText": "Dies ist eine webbasierte Projektmanagement-App, die mit React, Vite und Firebase entwickelt wurde und es Benutzern ermöglicht, Projekte in einem kollaborativen Arbeitsbereich effizient zu verwalten. Die App bietet eine Reihe von Funktionen, darunter Benutzerauthentifizierung, Projekterstellung, Benutzerverwaltung, Projektverfolgung und Kommentierung von Projekten.",
    "para1": "Benutzerauthentifizierung: ermöglicht die Anmeldung, so dass sich Benutzer für ein Konto bei der App registrieren können, und die Anmeldung, so dass sich Benutzer einloggen können, um auf ihren personalisierten Arbeitsbereich zuzugreifen.",
    "para2": "Benutzerverwaltung: Die Funktionen zur Benutzerverwaltung umfassen die Möglichkeit, eine umfassende Liste aller registrierten Benutzer innerhalb des Arbeitsbereichs einzusehen. Außerdem können die Benutzer den Online- oder Offline-Status jedes Benutzers leicht erkennen.",
    "para3": "Projektverwaltung: Im Rahmen des Projektmanagements haben Benutzer die Möglichkeit, neue Projekte zu erstellen, indem sie Details wie Titel, Beschreibung, Fälligkeitsdatum und Typ angeben. Die Zusammenarbeit wird durch die Möglichkeit verbessert, Teammitglieder zu Projekten zuzuweisen. Über ein Dashboard können Benutzer alle bestehenden Projekte einsehen und Filter nach Kriterien wie Status oder Typ anwenden. Außerdem wird die Kommunikation durch die Möglichkeit erleichtert, Kommentare zu den Projektdetails hinzuzufügen. Schließlich können Benutzer Projekte als abgeschlossen markieren, wenn sie fertig sind.",
    "para4": "Zusammenfassend lässt sich sagen, dass sich die Funktionen zur Benutzerverwaltung darauf konzentrieren, Einblicke in registrierte Benutzer und deren Status zu geben, während die Funktionen zur Projektverwaltung die Erstellung von Projekten, die Zusammenarbeit im Team, die Projektübersicht, das Filtern, das Kommentieren und die Verfolgung des Projektabschlusses umfassen.",
    "technologies": "React, JavaScript, Node, Vite, Firebase/Firestore"
  },
  "project8": {
    "introText": "Eine Reise-App, die die Web-API von OpenWeatherMap.org nutzt, um nahtlos umfassende Wetterdaten für benutzerdefinierte Ziele abzurufen und zu liefern. Mit einer benutzerfreundlichen Oberfläche gewährleistet die App einen einfachen Zugriff auf vergangene, aktuelle und zukünftige Wetterbedingungen und ermöglicht es Reisenden, fundierte Entscheidungen auf der Grundlage genauer und aktueller Informationen zu treffen.",
    "para1": "Um die App nutzen zu können, müssen die Nutzer einen Zielort eingeben, indem sie den Namen der Stadt und das Reisedatum angeben. In Fällen, in denen keine Daten eingegeben werden, wird in den Standardeinstellungen Berlin als Zielort und das heutige Datum berücksichtigt. Wenn Sie auf die Schaltfläche Senden klicken, zeigt die Benutzeroberfläche sofort die Wetterdaten für das angegebene Ziel und Datum an.",
    "para2": "Benutzer können nach Wetterdaten nach Städtenamen suchen, indem sie die Open Weather Geocoding API nutzen, um Informationen aus ihrer umfangreichen Datenbank abzurufen. Wenn die eingegebene Stadt nicht in der Datenbank gefunden wird, wird eine Fehlermeldung erzeugt, um den Benutzer über das Problem zu informieren.",
    "para3": "Die App unterstützt Zukunftsprognosen für bis zu 1,5 Jahre im Voraus und bietet dem Nutzer die Flexibilität, weit im Voraus zu planen. Darüber hinaus können historische Wetterdaten für Zeiträume von über 40 Jahren abgerufen werden, was eine umfassende Palette von Informationen für verschiedene Zwecke bietet.",
    "para4": "Nach dem Absenden der Suche gibt die App detaillierte Wetterinformationen zurück, darunter den Namen der Stadt, das Datum, die Temperatur (in Celsius), die Bewölkung, den Niederschlag und ein Symbol, das die vorherrschenden Wetterbedingungen symbolisiert. Dieser umfassende Datensatz vermittelt dem Nutzer ein ganzheitliches Verständnis der Wettervorhersage für das von ihm gewählte Ziel und Datum.",
    "technologies": "HTML, CSS, JavaScript, Restful API, Express, Node, Webpack"
  },

  "toggleWork": {
    "hide": "Verbergen",
    "show": "Anzeigen"
  },
  "contactSection": {
    "title": "Kontakt",
    "text": "Wenn du Interesse an einer neuen, modernen Website oder Web-App hast, melde dich und lass uns den Ball ins Rollen bringen!"
  },
  "references": {
    "title": "Kundenrenzensionen"
  },
  "referenceData": [
    {
      "quote": "Professionell und kundenfreundlich",
      "text": "Mark war sehr nett und freundlich. Er war geduldig und kommunikativ während des Entwicklungsprozesses, und ich bin mit dem Ergebnis sehr zufrieden. Ich würde ihn sehr empfehlen.",
      "image": "language-coach-aa.png",
      "link": "https://language-coach-aa.com/",
      "linkText": "Language Coach Andrea Ahlborn"
    }
  ]
}
